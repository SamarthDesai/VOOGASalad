# voogasalad

* Archana Ahlawat, Nik Bramblett, Dara Buggay, Ryan Chung, Samarth Desai, Ian Eldridge-Allegra, Aaron Paskin, Sam Slack, Owen Smith, David Tran
* Started on October 31st, ended on December 15th, estimated 1,500 hours total amongst all group members spent on the project
* Each person's role in the project:
    * Archana:
    * Nik:
    * Dara: Implemented UI interaction with sprites and the grid. Created editable UI components for parameters that are displayed upon sprite selection. Created Displayable abstract hierarchy which is extended by Dialogues, Cutscenes, and Inventories. Added most of the functionality in creating and editing dialogues & cutscenes. Helped debug and refactor the authoring environment. Also helped format most all of the auth env UI, including the different views.
    * Ryan: helped design general layout of GUI, and worked on implementing SpriteCreator.
    * Samarth: Created the Welcome Screen, designed the GUI, worked on the Player and connecting the Player with Engine along with Ian, worked on various Authoring functionalities and Views with Sam, created the language Locale.
    * Ian: Designed and developed collision handling system, drawing utility, and BoundingPolygonCreator; Developed the basic GameDataHandler (excluding the authoring-specific components) and then converted it to save to a directory selected by the user outside the workspace; Handled text display for the engine; designed and implemented factories to give authoring access to all operations and actions along with their parameters (including designing the annotation system used for parameters); implemented many of the actions/operations; assisted in implementing the visitor pattern for Displayables.
    * Aaron: designed and implemented Actions/Conditions, Inventory and Holdables, and contributed heavily to overall Engine design. Also helped implement camera functionality.
    * Sam:
    * Owen: responsible for managing authoring actions and conditions, loading and saving information about them to spriteObjects, and passing and receiving that information from the data stored in XML files for games.
    * David: Designed the UI for the recursive tree aspect of authoring actions and conditions; Worked with Ian to use the annotation system to store actions/operations; Designed the UI for selecting games to play; Developed the initial stages of dialogue authoring.
* Resources: Java documentation on list change listeners, lambda expressions, and layout components like HBoxes, VBoxes, TreeViews, and tabs, Program Creek for examples on list change listeners, StackOverflow for researching specific, small algorithms that were useful, and newthinktank.com for an example on MVC.
* Files used to start the project: default_pkg.Main launches SceneController, which creates the welcome screen from which the user can either play a pre-existing game, build their own game, or view the settings for the game. 
* Files used to test the project: Most of these are now outdated, and thus have been deleted, but everything in engine.Testing was used to generate games prior to integration with authoring. 
* Errors our program can handle without crashing: incorrectly filing in information about actions and conditions or leaving fields blank in the tree, incorrectly pairing a variable name to a sprite object to assign for a condition or action, and failing to pair at least one condition with every action, creating a project with a duplicate name, having multiple sprite templates with the same name
* Data or resource files required by the project: in the TextResources package, there are several properties containing titles and labels used in the conditions and actions tab. Actions.properties, Operations.properties, and the properties files that are referenced within those (ie each action category and each operation type has a properties file). The drawing utility uses a properties file to find its tool classes. The resources folder contains several images used within authoring, and the languages subpackage contains the language locales that are supported. local.properties holds the file path selected for storing/loading games, including a resources folder holding a text file of all exported games.
* Information about using the program: to play a game, select the play game button in the menu and click on a previously created game. To build a game, select create. Create sprite objects, which can be viewed under default sprite objects, and place them on the scene wherever. Their images can be created by loading an image file or drawing them with the drawing tool. Ultimately they are saved by clicking the create button. Edit their properties by clicking on them and editing information about their proprties like actions and conditions, parameters, and dialogue. When editing a sprite object, it is important to click the apply button to save any changes. The game can be saved by going to file and clicking save, and then can be re-run and edited by going to play and selecting the game the user saved. An important note: when first opening the program, you will be prompted to select an empty directory on your system -- it really does have to be empty unless it has been populated only by our program. This will then be saved to local.properties (you may have to refresh eclipse's file system for this change to be recognized the next time). This will be your working directory. If you want the already created games, copy the Demo Games directory from data onto your computer, and select that as your working directory. 
* Decisions, assumptions, or simplifications made: in making our role playing game, the genre isn't exactly defined, so we took that to mean make a game building application that can support as many games as possible. In the end, we had functionality for genres like RPG, platformer, puzzle, and arcade shooting games. There was a lot of debate regarding whether or not to use a grid -- ultimately the decision was that the engine would not use a grid (otherwise it would be difficult to produce smooth movement) but the authoring environment would to make it easier for the user. This does place some limitations on what the user can do and how specific they can be in their game design, but it also simplifies the process. 
* Known bugs, crashes, or problems with the project's functionality: regarding actions and conditions, cannot copy actions and conditions from one sprite object onto another, cannot completely load the treeview of actions and conditions of each sprite object after being saved, and cannot create sprite actions and conditions from the sprite creator (only in the map editor). 
* Extra features included: Our game engine has a game data producer and viewer, which allows the user to view information about any object at any point in the game like its position and parameters. Press f1 to use it. 
* Impressions of assignment: voogasalad was a great final project for the semester because it allowed for the most design freedom and creativity, which definitely expanded given the experience gained from previous projects. It was definitely difficult to manage roles within a 10 person team, but our team skills definitely improved as a result. Of course, our coding skills really improved since we had to program so much more for this project and think in a more modular way. We also learned about serialization and JavaFX features like CSS styling. 